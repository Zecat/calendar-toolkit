<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="moment-import.html">

<script>
  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.CalendarSelectionBehavior
   */
  Polymer.CalendarSelectionBehavior = {
  	
  	properties: {
      immediateStartDate: {
        type: Date,
        notify: true
      },
      immediateEndDate: {
        type: Date,
        notify: true
      },
      lastStartDate: {
        type: Date,
        notify: true
      },
      lastEndDate: {
        type: Date,
        notify: true
      },
      selecting: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        observer: '_selectingChange'
      },
      selectionDisabled : {
        type: Boolean,
        value: false,
        observer: '_selectionDisabledChange'
      },
      touchSelectionDelay: {
        type: Number,
        value: 500
      },
      touchSelectionMaxYTremor: {
        type: Number,
        value: 10
      },
      _hoveredStartTimestamp: {
        type: Number,
        readOnly: true
      },
      _hoveredTimestamp: {
        type: Number,
        computed: '_getTimestampFromTarget(_hoveredTarget)',
        observer: '_hoveredTimestampChange'
      },
      _hoveredTarget: {
        type: Object,
        readOnly: true
      },
      _touching: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      _touchStartY: {
        type: Number,
        readOnly: true
      },
      _waitForTouchSelection: {
        type: Boolean,
        vaue: false,
        readOnly: true
      }
    },

    observers: [
      '_touchSelectingHandler(selecting, _touching)',
      '_hoveredIntervalChange(_hoveredStartTimestamp, _hoveredTimestamp)'
    ],

    _selectionDisabledChange: function(selectionDisabled) {
      if (!selectionDisabled) {
        this.listen(this, 'touchstart', '_touchStartHandler');
        this.listen(this, 'touchend', '_touchEndHandler');
        this.listen(this, 'mouseup', '_mouseupHandler');
        this.listen(this, 'down', '_downHandler');
        this.listen(this, 'track', '_trackHandler');
      }
      else {
        this.unlisten(this, 'touchstart', '_touchStartHandler');
        this.unlisten(this, 'touchend', '_touchEndHandler');
        this.unlisten(this, 'mouseup', '_mouseupHandler');
        this.unlisten(this, 'down', '_downHandler');
        this.unlisten(this, 'track', '_trackHandler');
        this._set_touching(false);
        this._setSelecting(false);
      }
    },

    _downHandler: function(e) {
      if (this._touching && this.touchSelectionDelay) {
        this._set_touchStartY(e.detail.y);
        this._set_waitForTouchSelection(true);
        this.listen(this, 'touchmove', '_shouldCancelTouch');
        this.async(function(){
          this.unlisten(this, 'touchmove', '_shouldCancelTouch');
          if (this._waitForTouchSelection) {
            this._set_waitForTouchSelection(false);
            this._startSelection(e);
          }
        }, this.touchSelectionDelay);
      } else {
        this._startSelection(e);
      }
    },

    _hoveredIntervalChange: function(_hoveredStartTimestamp, _hoveredTimestamp) {
      var minDate = Math.min(_hoveredStartTimestamp, _hoveredTimestamp);
      var maxDate = Math.max(_hoveredStartTimestamp, _hoveredTimestamp);

      if (!moment(minDate).isSame(this.immediateStartDate)) {
        this.immediateStartDate = new Date(minDate);
      }
      if (!moment(maxDate).isSame(this.immediateEndDate)) {
        this.immediateEndDate = new Date(maxDate);
      }
    },

    _mouseupHandler: function() {
      this._setSelecting(false);
    },

    _preventDefault: function(e) {
      e.preventDefault();
    },

    _shouldCancelTouch: function(e) {
      if (Math.abs(this._touchStartY - e.touches[0].clientY) > this.touchSelectionMaxYTremor) {
        this._set_waitForTouchSelection(false);
      }
    },

    _startSelection: function(e) {
      this._setSelecting(true);
      if (e.target.classList.contains('dayWrapper')) {
        this._set_hoveredTarget(e.target);
      }
    },

    _touchStartHandler: function(e) {
      this._set_touching(true);
    },

    _touchEndHandler: function(e) {
      if (this._waitForTouchSelection) {
        this._startSelection(e);
        this._set_waitForTouchSelection(false);
      }
      this._set_touching(false);
    },

    _trackHandler: function(e) {
      if (this.selecting) {
        switch (e.detail.state) {
          case 'track':
            var hovered = e.detail.hover();
            if (hovered && hovered.classList.contains('dayWrapper')) {
              this._set_hoveredTarget(hovered);
            }
          break;
          case 'end':
            this._setSelecting(false);
        }
      }
    },

    _touchSelectingHandler: function(selecting, _touching) {
      if (selecting) {
        if (_touching) {
          this.listen(this, 'touchmove', '_preventDefault');
        } else {
          this.unlisten(this, 'touchmove', '_preventDefault');
        }
      }
    },

    _getModelFromDayTarget: function(target) {
      return Polymer.dom(Polymer.dom(target).parentNode).lastElementChild.modelForElement(target);
    },

    _getTimestampFromTarget: function(target) {
      return target ? this._getModelFromDayTarget(target).__data__.day.timestamp : undefined;
    },

    _hoveredTimestampChange: function(_hoveredTimestamp, _previousHoveredTimestamp) {
      if (_hoveredTimestamp == undefined) {
        this.immediateStartDate = undefined;
        this.immediateEndDate = undefined;
      } else if (_previousHoveredTimestamp == undefined) {
        this._set_hoveredStartTimestamp(_hoveredTimestamp);
      }
    },

    _selectingChange: function(selecting) {
      if (!selecting) {
        this.lastStartDate = this.immediateStartDate;
        this.lastEndDate = this.immediateEndDate;
        this._set_hoveredTarget(undefined);
      }
    },
  }

</script>