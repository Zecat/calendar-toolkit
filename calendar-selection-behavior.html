<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="moment-import.html">

<script>
  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.CalendarSelectionBehavior
   */
  Polymer.CalendarSelectionBehavior = {
  	
  	properties: {
      selecting: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      selectionDisabled : {
        type: Boolean,
        value: false,
        observer: '_selectionDisabledChange'
      },
      touchSelectionDelay: {
        type: Number,
        value: 500
      },
      touchSelectionMaxYTremor: {
        type: Number,
        value: 10
      },
      _hoveredStartDate: {
        type: Number,
        readOnly: true
      },
      _hoveredDate: {
        type: Number,
        computed: '_getDateFromTarget(_hoveredTarget)'
      },
      _hoveredTarget: {
        type: Object,
        readOnly: true
      },
      _touching: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      _touchStartY: {
        type: Number,
        readOnly: true
      },
      _waitForTouchSelection: {
        type: Boolean,
        vaue: false,
        readOnly: true
      }
    },

    observers: [
      '_touchSelectingHandler(selecting, _touching)'
    ],

    _selectionDisabledChange: function(selectionDisabled) {
      if (!selectionDisabled) {
        this.listen(this, 'touchstart', '_touchStartHandler');
        this.listen(this, 'touchend', '_touchEndHandler');
        this.listen(this, 'mouseup', '_mouseupHandler');
        this.listen(this, 'down', '_downHandler');
        this.listen(this, 'track', '_trackHandler');
      }
      else {
        this.unlisten(this, 'touchstart', '_touchStartHandler');
        this.unlisten(this, 'touchend', '_touchEndHandler');
        this.unlisten(this, 'mouseup', '_mouseupHandler');
        this.unlisten(this, 'down', '_downHandler');
        this.unlisten(this, 'track', '_trackHandler');
        this._set_touching(false);
        this._setSelecting(false);
      }
    },

    _downHandler: function(e) {
      if (this._touching && this.touchSelectionDelay) {
        this._set_touchStartY(e.detail.y);
        this._set_waitForTouchSelection(true);
        this.listen(this, 'touchmove', '_shouldCancelTouch');
        this.async(function(){
          this.unlisten(this, 'touchmove', '_shouldCancelTouch');
          if (this._waitForTouchSelection) {
            this._set_waitForTouchSelection(false);
            this._startSelection(e);
          }
        }, this.touchSelectionDelay);
      } else {
        this._startSelection(e);
      }
    },

    _mouseupHandler: function() {
      this._setSelecting(false);
    },

    _preventDefault: function(e) {
      e.preventDefault();
    },

    _shouldCancelTouch: function(e) {
      if (Math.abs(this._touchStartY - e.touches[0].clientY) > this.touchSelectionMaxYTremor) {
        this._set_waitForTouchSelection(false);
      }
    },

    _startSelection: function(e) {
      this._setSelecting(true);
      if (e.target.classList.contains('dayWrapper')) {
        this._set_hoveredTarget(e.target);
      }
    },

    _touchStartHandler: function(e) {
      this._set_touching(true);
    },

    _touchEndHandler: function(e) {
      if (this._waitForTouchSelection) {
        this._startSelection(e);
        this._set_waitForTouchSelection(false);
      }
      this._set_touching(false);
    },

    _trackHandler: function(e) {
      if (this.selecting) {
        switch (e.detail.state) {
          case 'track':
            var hovered = e.detail.hover();
            if (hovered && hovered.classList.contains('dayWrapper')) {
              this._set_hoveredTarget(hovered);
            }
          break;
          case 'end':
            this._setSelecting(false);
        }
      }
    },

    _touchSelectingHandler: function(selecting, _touching) {
      if (selecting) {
        if (_touching) {
          this.listen(this, 'touchmove', '_preventDefault');
        } else {
          this.unlisten(this, 'touchmove', '_preventDefault');
        }
      }
    },

    _getModelFromDayTarget: function(target) {
      return Polymer.dom(Polymer.dom(target).parentNode).lastElementChild.modelForElement(target);
    },

    _getDateFromTarget: function(target) {
      return target ? new Date(this._getModelFromDayTarget(target).__data__.day.timestamp) : undefined;
    }

  }

</script>