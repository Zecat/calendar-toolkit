<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="moment-import.html">

<script>
  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.DateSelectionBehavior
   */
  Polymer.DateSelectionBehavior = {
  	
  	properties: {
      selecting: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      selectionDisabled : {
        type: Boolean,
        value: false,
        observer: '_selectionDisabledChange'
      },
      touchSelectionDelay: {
        type: Number,
        value: 500
      },
      touchSelectionMaxYTremor: {
        type: Number,
        value: 10
      },
      _dayClass: {
        type: String,
        value: 'dayWrapper'
      },
      _hoveredStartDate: {
        type: Number,
        readOnly: true
      },
      hoveredDate: {
        type: Number,
        computed: '_computeHoveredDate(_hoveredTarget)'
      },
      _hoveredTarget: {
        type: Object,
        readOnly: true
      },
      touching: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      _touchStartY: {
        type: Number,
        readOnly: true
      },
      _waitForTouchSelection: {
        type: Boolean,
        vaue: false,
        readOnly: true
      }
    },

    _selectionDisabledChange: function(selectionDisabled) {
      if (!selectionDisabled) {
        this.listen(this, 'touchstart', '_touchStartHandler');
        this.listen(this, 'touchend', '_touchEndHandler');
        this.listen(this, 'mouseup', '_mouseupHandler');
        this.listen(this, 'down', '_downHandler');
        this.listen(this, 'track', '_trackHandler');
      }
      else {
        this.unlisten(this, 'touchstart', '_touchStartHandler');
        this.unlisten(this, 'touchend', '_touchEndHandler');
        this.unlisten(this, 'mouseup', '_mouseupHandler');
        this.unlisten(this, 'down', '_downHandler');
        this.unlisten(this, 'track', '_trackHandler');
        this._setTouching(false);
        this._setSelecting(false);
      }
    },

    _downHandler: function(e) {
      if (this.touching && this.touchSelectionDelay) {
        this._set_touchStartY(e.detail.y);
        this._set_waitForTouchSelection(true);
        this.listen(this, 'touchmove', '_shouldCancelTouch');
        this.async(function(){
          this.unlisten(this, 'touchmove', '_shouldCancelTouch');
          if (this._waitForTouchSelection) {
            this._set_waitForTouchSelection(false);
            this._startSelection(e);
          }
        }, this.touchSelectionDelay);
      } else {
        this._startSelection(e);
      }
    },

    _mouseupHandler: function() {
      this._setSelecting(false);
    },

    _shouldCancelTouch: function(e) {
      if (Math.abs(this._touchStartY - e.touches[0].clientY) > this.touchSelectionMaxYTremor) {
        this._set_waitForTouchSelection(false);
      }
    },

    _startSelection: function(e) {
      this._setSelecting(true);
      if (e.target.classList.contains(this._dayClass)) {
        this._set_hoveredTarget(e.target);
      }
    },

    _touchStartHandler: function(e) {
      this._setTouching(true);
    },

    _touchEndHandler: function(e) {
      if (this._waitForTouchSelection) {
        this._startSelection(e);
        this._set_waitForTouchSelection(false);
      }
      this._setTouching(false);
    },

    _trackHandler: function(e) {
      if (this.selecting) {
        switch (e.detail.state) {
          case 'track':
            var hovered = e.detail.hover();
            if (hovered && hovered.classList.contains(this._dayClass)) {
              this._set_hoveredTarget(hovered);
            }
          break;
          case 'end':
            this._setSelecting(false);
        }
      }
    },

    /* Override this method with your own logic and return a Date object from the given target. We have already check that the target is defined and contains the class given by "dayClass" attribute. */
    _getDateFromTarget: function(target) {
      
    },

    _computeHoveredDate: function(target) {
      return target ? this._getDateFromTarget(target) : undefined;
    }

  }

</script>